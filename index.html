<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy"
    content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; media-src 'self' blob:; img-src 'self' data:;">
  <title>Screen Recorder</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', -apple-system, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #18181b 100%);
      min-height: 100vh;
      color: #fafafa;
      overflow: hidden;
    }

    .app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      border: 1px solid rgba(118, 75, 162, 0.3);
      border-radius: 12px;
      overflow: hidden;
    }

    /* Custom Title Bar */
    .title-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 10px;
      height: 34px;
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      box-shadow: 0 2px 10px rgba(79, 70, 229, 0.3);
      -webkit-app-region: drag;
      user-select: none;
    }

    .title-bar-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .app-icon {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      overflow: hidden;
    }

    .app-icon img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .title-bar-title {
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .title-bar-controls {
      display: flex;
      align-items: center;
      gap: 4px;
      -webkit-app-region: no-drag;
    }

    .title-bar-btn {
      width: 28px;
      height: 24px;
      border: none;
      background: transparent;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s ease;
      color: rgba(255, 255, 255, 0.9);
    }

    .title-bar-btn:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .title-bar-btn.close:hover {
      background: #e53e3e;
      color: #fff;
    }

    .title-bar-btn svg {
      width: 12px;
      height: 12px;
    }

    /* Header */
    .header {
      padding: 10px 16px;
      border-bottom: 1px solid rgba(118, 75, 162, 0.2);
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(102, 126, 234, 0.05);
    }

    .logo {
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
    }

    .logo svg {
      width: 12px;
      height: 12px;
      fill: #fff;
    }

    .header h1 {
      font-size: 16px;
      font-weight: 600;
      color: #fafafa;
      flex: 1;
      background: linear-gradient(135deg, #fff 0%, #c4b5fd 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .github-link {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #a78bfa;
      transition: all 0.15s ease;
      cursor: pointer;
      border-radius: 8px;
      background: rgba(118, 75, 162, 0.1);
    }

    .github-link:hover {
      color: #fafafa;
      background: rgba(118, 75, 162, 0.3);
    }

    .github-link svg {
      width: 18px;
      height: 18px;
    }

    /* Main content */
    .main {
      flex: 1;
      padding: 14px;
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      grid-template-rows: auto auto auto auto auto;
      gap: 12px;
      overflow-y: auto;
    }
    
    .main > .preview-container {
      grid-column: 1;
      grid-row: 1 / 6;
    }
    
    .main > .timer-row {
      grid-column: 2;
      grid-row: 1;
    }
    
    .main > .section:nth-of-type(1) {
      grid-column: 2;
      grid-row: 2;
    }
    
    .main > .section:nth-of-type(2) {
      grid-column: 2;
      grid-row: 3;
    }
    
    .main > .section:nth-of-type(3) {
      grid-column: 2;
      grid-row: 4;
    }
    
    .main > .controls {
      grid-column: 1 / 3;
      grid-row: 6;
      margin-top: 4px;
    }

    /* Preview */
    .preview-container {
      background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      border: 1px solid rgba(139, 92, 246, 0.3);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.08);
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .preview-video {
      width: 100%;
      height: 100%;
      max-height: 400px;
      object-fit: contain;
      display: block;
    }

    .preview-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
      pointer-events: none;
    }

    .preview-overlay span {
      color: #6b7280;
      font-size: 13px;
    }

    .preview-overlay.hidden {
      display: none;
    }

    /* Timer */
    .timer-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 18px;
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.12) 0%, rgba(124, 58, 237, 0.08) 100%);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 10px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .timer {
      font-size: 28px;
      font-weight: 700;
      font-family: 'Consolas', 'SF Mono', monospace;
      background: linear-gradient(135deg, #fff 0%, #c4b5fd 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: 1px;
    }

    .status-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      background: rgba(102, 126, 234, 0.15);
      border: 1px solid rgba(118, 75, 162, 0.3);
      border-radius: 16px;
      font-size: 10px;
      font-weight: 600;
      color: #a78bfa;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .status-badge.recording {
      background: rgba(239, 68, 68, 0.15);
      border-color: rgba(239, 68, 68, 0.4);
      color: #fca5a5;
    }

    .status-badge.paused {
      background: rgba(234, 179, 8, 0.15);
      border-color: rgba(234, 179, 8, 0.4);
      color: #fde047;
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
      box-shadow: 0 0 6px currentColor;
    }

    .status-badge.recording .status-dot {
      animation: pulse 1.2s ease-in-out infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: 0.5;
        transform: scale(0.8);
      }
    }

    /* Sections */
    .section {
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.08) 0%, rgba(124, 58, 237, 0.05) 100%);
      border: 1px solid rgba(139, 92, 246, 0.25);
      border-radius: 10px;
      padding: 12px 14px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #a78bfa;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .section-header svg {
      width: 14px;
      height: 14px;
    }

    /* Source list */
    .source-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .source-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(79, 70, 229, 0.08);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .source-item:hover {
      background: rgba(79, 70, 229, 0.15);
      border-color: rgba(139, 92, 246, 0.35);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
    }

    .source-item.selected {
      border-color: #8b5cf6;
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.2) 0%, rgba(124, 58, 237, 0.15) 100%);
      box-shadow: 0 0 24px rgba(139, 92, 246, 0.3), 0 4px 12px rgba(79, 70, 229, 0.2);
    }

    .source-thumb {
      width: 44px;
      height: 28px;
      border-radius: 4px;
      object-fit: cover;
      background: #1a1a2e;
      border: 1px solid rgba(118, 75, 162, 0.2);
    }

    .source-name {
      font-size: 13px;
      color: #e4e4e7;
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .source-check {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(118, 75, 162, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .source-item.selected .source-check {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: transparent;
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
    }

    .source-check svg {
      width: 10px;
      height: 10px;
      opacity: 0;
    }

    .source-item.selected .source-check svg {
      opacity: 1;
    }

    /* Selection source specific */
    .source-item.selection-source {
      display: flex;
      flex-wrap: wrap;
    }

    .selection-btn {
      margin-top: 8px;
      margin-left: 54px;
      width: calc(100% - 54px - 30px);
      padding: 6px 12px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.2s ease;
    }

    .source-item.selection-source.selected .selection-btn {
      display: flex;
    }

    .selection-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .selection-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .selection-btn svg {
      width: 12px;
      height: 12px;
    }

    .selection-preview {
      margin-top: 6px;
      margin-left: 54px;
      width: calc(100% - 54px - 30px);
      padding: 6px 10px;
      background: rgba(102, 126, 234, 0.1);
      border: 1px solid rgba(118, 75, 162, 0.2);
      border-radius: 6px;
      font-size: 11px;
      color: #a78bfa;
      display: none;
    }

    .source-item.selection-source.selected .selection-preview.has-selection {
      display: block;
    }

    /* Audio options */
    .audio-row {
      display: flex;
      gap: 12px;
    }

    .audio-option {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(102, 126, 234, 0.08);
      border: 1px solid rgba(118, 75, 162, 0.15);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .audio-option:hover {
      background: rgba(102, 126, 234, 0.15);
      border-color: rgba(118, 75, 162, 0.3);
    }

    .audio-option input {
      display: none;
    }

    .toggle {
      width: 34px;
      height: 18px;
      background: rgba(118, 75, 162, 0.3);
      border-radius: 9px;
      position: relative;
      transition: all 0.25s ease;
    }

    .toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 14px;
      height: 14px;
      background: #6b7280;
      border-radius: 50%;
      transition: all 0.25s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .audio-option input:checked+.toggle {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      box-shadow: 0 2px 10px rgba(102, 126, 234, 0.4);
    }

    .audio-option input:checked+.toggle::after {
      left: 18px;
      background: #fff;
    }

    .audio-label {
      font-size: 13px;
      color: #9ca3af;
      font-weight: 500;
    }

    .audio-option input:checked~.audio-label {
      color: #e4e4e7;
    }

    /* Output format */
    .format-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .format-select-wrapper {
      flex: 1;
      position: relative;
    }

    .format-select {
      width: 100%;
      padding: 10px 36px 10px 12px;
      background: rgba(102, 126, 234, 0.08);
      border: 1px solid rgba(118, 75, 162, 0.15);
      border-radius: 8px;
      color: #e4e4e7;
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      appearance: none;
      transition: all 0.2s ease;
    }

    .format-select:hover {
      background: rgba(102, 126, 234, 0.15);
      border-color: rgba(118, 75, 162, 0.3);
    }

    .format-select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
    }

    .format-select option {
      background: #1a1a2e;
      color: #e4e4e7;
      padding: 8px;
    }

    .format-select-wrapper::after {
      content: '';
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid #a78bfa;
      pointer-events: none;
    }

    .format-note {
      font-size: 10px;
      color: #6b7280;
      margin-top: 4px;
    }

    .format-note.warning {
      color: #fbbf24;
    }

    /* Controls */
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: auto;
      padding-top: 14px;
      border-top: 1px solid rgba(118, 75, 162, 0.15);
    }

    .btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 18px;
      border: none;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .btn:disabled {
      opacity: 0.35;
      cursor: not-allowed;
      transform: none !important;
    }

    .btn svg {
      width: 16px;
      height: 16px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #f87171 0%, #dc2626 50%, #b91c1c 100%);
      color: #fff;
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.45), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 28px rgba(239, 68, 68, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
      background: linear-gradient(135deg, #fca5a5 0%, #ef4444 50%, #dc2626 100%);
    }

    .btn-primary:active:not(:disabled) {
      transform: translateY(0);
    }

    .btn-row {
      display: flex;
      gap: 12px;
    }

    .btn-secondary {
      flex: 1;
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.15) 0%, rgba(124, 58, 237, 0.1) 100%);
      border: 1px solid rgba(139, 92, 246, 0.35);
      color: #e4e4e7;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    .btn-secondary:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.25) 0%, rgba(124, 58, 237, 0.2) 100%);
      border-color: rgba(139, 92, 246, 0.5);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(102, 126, 234, 0.25);
      border-color: rgba(118, 75, 162, 0.5);
      transform: translateY(-1px);
    }

    .btn-ghost {
      background: transparent;
      color: #a1a1aa;
      border: 1px solid rgba(139, 92, 246, 0.25);
    }

    .btn-ghost:hover:not(:disabled) {
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.1) 0%, rgba(124, 58, 237, 0.08) 100%);
      border-color: rgba(139, 92, 246, 0.4);
      color: #c4b5fd;
    }

    /* Toast */
    .toast {
      position: fixed;
      top: 70px;
      right: 20px;
      max-width: 350px;
      padding: 12px 16px;
      background: rgba(17, 24, 39, 0.95);
      border: 1px solid rgba(167, 139, 250, 0.4);
      backdrop-filter: blur(16px);
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      color: #f3f4f6;
      transform: translateX(400px);
      opacity: 0;
      transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(167, 139, 250, 0.1);
      z-index: 10000;
    }

    .toast.show {
      transform: translateX(0);
      opacity: 1;
    }

    .toast.success {
      border-color: rgba(34, 197, 94, 0.6);
      background: rgba(17, 24, 39, 0.95);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6), 0 0 20px rgba(34, 197, 94, 0.15);
    }

    .toast.error {
      border-color: rgba(239, 68, 68, 0.6);
      background: rgba(17, 24, 39, 0.95);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6), 0 0 20px rgba(239, 68, 68, 0.15);
    }

    .toast.info {
      border-color: rgba(59, 130, 246, 0.6);
      background: rgba(17, 24, 39, 0.95);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6), 0 0 20px rgba(59, 130, 246, 0.15);
    }

    .toast svg {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .toast.success svg {
      color: #22c55e;
    }

    .toast.error svg {
      color: #ef4444;
    }

    .toast.info svg {
      color: #3b82f6;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(118, 75, 162, 0.3);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(118, 75, 162, 0.5);
    }

    /* Monitor Selection Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 1px solid rgba(118, 75, 162, 0.3);
      border-radius: 12px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal h3 {
      color: #fff;
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      text-align: center;
    }

    .monitor-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 16px;
    }

    .monitor-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: rgba(102, 126, 234, 0.1);
      border: 1px solid rgba(118, 75, 162, 0.2);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .monitor-item:hover {
      background: rgba(102, 126, 234, 0.2);
      border-color: rgba(118, 75, 162, 0.4);
    }

    .monitor-item svg {
      width: 32px;
      height: 32px;
      color: #a78bfa;
    }

    .monitor-info {
      flex: 1;
    }

    .monitor-name {
      font-size: 13px;
      font-weight: 600;
      color: #e4e4e7;
    }

    .monitor-details {
      font-size: 11px;
      color: #6b7280;
      margin-top: 2px;
    }

    .modal-cancel {
      width: 100%;
      padding: 10px;
      background: transparent;
      border: 1px solid rgba(118, 75, 162, 0.3);
      border-radius: 8px;
      color: #a1a1aa;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .modal-cancel:hover {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.3);
      color: #ef4444;
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- Custom Title Bar -->
    <div class="title-bar">
      <div class="title-bar-left">
        <div class="app-icon">
          <img src="icon.png" alt="Screen Recorder">
        </div>
        <span class="title-bar-title">Screen Recorder</span>
      </div>
      <div class="title-bar-controls">
        <button class="title-bar-btn" id="minimizeBtn" title="Minimize">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="5" y1="12" x2="19" y2="12" />
          </svg>
        </button>
        <button class="title-bar-btn" id="maximizeBtn" title="Maximize">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="5" y="5" width="14" height="14" rx="1" />
          </svg>
        </button>
        <button class="title-bar-btn close" id="closeBtn" title="Close">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="6" y1="6" x2="18" y2="18" />
            <line x1="6" y1="18" x2="18" y2="6" />
          </svg>
        </button>
      </div>
    </div>

    <div class="header">
      <div class="logo">
        <svg viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="6" />
        </svg>
      </div>
      <h1>Screen Recorder</h1>
      <a class="github-link" id="githubLink" href="#" title="View on GitHub">
        <svg viewBox="0 0 24 24" fill="currentColor">
          <path
            d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z" />
        </svg>
      </a>
    </div>

    <div class="main">
      <div class="preview-container">
        <video class="preview-video" id="preview" autoplay muted></video>
        <div class="preview-overlay" id="previewOverlay">
          <span>No preview available</span>
        </div>
      </div>

      <div class="timer-row">
        <div class="timer" id="timer">00:00:00</div>
        <div class="status-badge" id="statusBadge">
          <span class="status-dot"></span>
          <span id="statusText">Ready</span>
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="2" y="3" width="20" height="14" rx="2" />
            <line x1="8" y1="21" x2="16" y2="21" />
            <line x1="12" y1="17" x2="12" y2="21" />
          </svg>
          <span>Select Source</span>
        </div>
        <div class="source-list" id="sourceList">
          <div class="source-item">
            <span class="source-name">Loading sources...</span>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
            <path d="M15.54 8.46a5 5 0 0 1 0 7.07" />
          </svg>
          <span>Audio</span>
        </div>
        <div class="audio-row">
          <label class="audio-option">
            <input type="checkbox" id="systemAudio" checked>
            <span class="toggle"></span>
            <span class="audio-label">System</span>
          </label>
          <label class="audio-option">
            <input type="checkbox" id="micAudio" checked>
            <span class="toggle"></span>
            <span class="audio-label">Microphone</span>
          </label>
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
            <polyline points="14 2 14 8 20 8" />
            <line x1="12" y1="18" x2="12" y2="12" />
            <line x1="9" y1="15" x2="15" y2="15" />
          </svg>
          <span>Output Format</span>
        </div>
        <div class="format-row">
          <div class="format-select-wrapper">
            <select class="format-select" id="outputFormat">
              <option value="webm">WebM (Native, Fast)</option>
              <option value="mp4">MP4 (H.264, Universal)</option>
              <option value="mkv">MKV (Matroska)</option>
              <option value="mov">MOV (QuickTime)</option>
              <option value="avi">AVI (Legacy)</option>
            </select>
          </div>
        </div>
        <div class="format-note" id="formatNote">WebM is recorded natively without conversion</div>
      </div>

      <div class="controls">
        <button class="btn btn-primary" id="startBtn" disabled>
          <svg viewBox="0 0 24 24" fill="currentColor">
            <circle cx="12" cy="12" r="6" />
          </svg>
          Start Recording
        </button>
        <div class="btn-row">
          <button class="btn btn-secondary" id="pauseBtn" disabled>
            <svg viewBox="0 0 24 24" fill="currentColor">
              <rect x="6" y="4" width="4" height="16" />
              <rect x="14" y="4" width="4" height="16" />
            </svg>
            Pause
          </button>
          <button class="btn btn-secondary" id="stopBtn" disabled>
            <svg viewBox="0 0 24 24" fill="currentColor">
              <rect x="6" y="6" width="12" height="12" rx="2" />
            </svg>
            Stop
          </button>
        </div>
        <button class="btn btn-ghost" id="resetBtn" disabled>
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z" />
          </svg>
          Reset
        </button>
      </div>
    </div>
  </div>

  <!-- Monitor Selection Modal -->
  <div class="modal-overlay" id="monitorModal">
    <div class="modal">
      <h3>Select Monitor for Selection Area</h3>
      <div class="monitor-list" id="monitorList">
        <!-- Monitors will be populated dynamically -->
      </div>
      <button class="modal-cancel" id="cancelMonitorBtn">Cancel</button>
    </div>
  </div>

  <div class="toast" id="notification">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
      <polyline points="22 4 12 14.01 9 11.01" />
    </svg>
    <span id="notificationText"></span>
  </div>

  <script>
    const timerDisplay = document.getElementById('timer');
    const statusBadge = document.getElementById('statusBadge');
    const statusText = document.getElementById('statusText');
    const sourceList = document.getElementById('sourceList');
    const systemAudioCheckbox = document.getElementById('systemAudio');
    const micAudioCheckbox = document.getElementById('micAudio');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const preview = document.getElementById('preview');
    const previewOverlay = document.getElementById('previewOverlay');
    const notification = document.getElementById('notification');
    const notificationText = document.getElementById('notificationText');
    const outputFormatSelect = document.getElementById('outputFormat');
    const formatNote = document.getElementById('formatNote');

    let mediaRecorder = null;
    let recordedChunks = [];
    let selectedSource = null;
    let timerInterval = null;
    let elapsedSeconds = 0;
    let isRecording = false;
    let isPaused = false;
    let mediaStream = null;
    let selectionArea = null; // For selection recording
    let ffmpegAvailable = false;

    // Check FFmpeg availability on load
    async function checkFfmpeg() {
      try {
        ffmpegAvailable = await window.electronAPI.checkFfmpeg();
        updateFormatNote();
      } catch (e) {
        ffmpegAvailable = false;
      }
    }

    function updateFormatNote() {
      const format = outputFormatSelect.value;
      if (format === 'webm') {
        formatNote.textContent = 'WebM is recorded natively without conversion';
        formatNote.className = 'format-note';
      } else if (!ffmpegAvailable) {
        formatNote.textContent = '⚠ FFmpeg not found. Install FFmpeg or use WebM format.';
        formatNote.className = 'format-note warning';
      } else {
        const formatDescriptions = {
          'mp4': 'MP4 will be converted after recording (H.264/AAC)',
          'mkv': 'MKV will be converted after recording (H.264/AAC)',
          'mov': 'MOV will be converted after recording (H.264/AAC)',
          'avi': 'AVI will be converted after recording (Xvid/MP3)'
        };
        formatNote.textContent = formatDescriptions[format] || '';
        formatNote.className = 'format-note';
      }
    }

    outputFormatSelect.addEventListener('change', updateFormatNote);

    function showNotification(message, type = 'info') {
      notificationText.textContent = message;
      notification.className = 'toast show ' + type;
      setTimeout(() => notification.classList.remove('show'), 3000);
    }

    function formatTime(seconds) {
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function updateTimer() {
      elapsedSeconds++;
      timerDisplay.textContent = formatTime(elapsedSeconds);
    }

    function updateStatus(status) {
      statusText.textContent = status;
      statusBadge.className = 'status-badge';
      if (status === 'Recording') statusBadge.classList.add('recording');
      else if (status === 'Paused') statusBadge.classList.add('paused');
    }

    async function loadSources() {
      try {
        const sources = await window.electronAPI.getSources();
        if (sources.length === 0) {
          showNotification('No screen sources found', 'error');
          return;
        }

        sourceList.innerHTML = '';

        // Add regular screen sources
        sources.forEach(source => {
          const item = document.createElement('div');
          item.className = 'source-item';
          item.innerHTML = `
            <img class="source-thumb" src="${source.thumbnail}" alt="">
            <span class="source-name">${source.name}</span>
            <span class="source-check">
              <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3">
                <polyline points="20 6 9 17 4 12"/>
              </svg>
            </span>
          `;
          item.onclick = () => selectSource(source, item);
          sourceList.appendChild(item);
        });

        // Add Selection source option
        const selectionItem = document.createElement('div');
        selectionItem.className = 'source-item selection-source';
        selectionItem.id = 'selectionSourceItem';
        selectionItem.innerHTML = `
          <div class="source-thumb" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
            <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" style="width: 20px; height: 20px;">
              <rect x="3" y="3" width="18" height="18" rx="2" stroke-dasharray="4 2"/>
              <path d="M9 3v18M15 3v18M3 9h18M3 15h18" stroke-opacity="0.3"/>
            </svg>
          </div>
          <span class="source-name">Selection (Region)</span>
          <span class="source-check">
            <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3">
              <polyline points="20 6 9 17 4 12"/>
            </svg>
          </span>
          <button class="selection-btn" id="selectAreaBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <path d="M12 8v8M8 12h8"/>
            </svg>
            Position Recording Area
          </button>
          <div class="selection-preview" id="selectionPreview"></div>
        `;
        selectionItem.onclick = (e) => {
          if (!e.target.closest('.selection-btn')) {
            selectSelectionSource(selectionItem);
          }
        };
        sourceList.appendChild(selectionItem);

        // Add click handler for selection button
        document.getElementById('selectAreaBtn').addEventListener('click', openSelectionWindow);
      } catch (error) {
        console.error('Error loading sources:', error);
        showNotification('Error loading sources', 'error');
      }
    }

    function selectSource(source, item) {
      selectedSource = source;
      selectionArea = null; // Clear any selection area
      document.querySelectorAll('.source-item').forEach(el => el.classList.remove('selected'));
      item.classList.add('selected');
      startBtn.disabled = false;
      showNotification('Source selected', 'success');
    }

    function selectSelectionSource(item) {
      selectedSource = { id: 'selection', name: 'Selection' };
      document.querySelectorAll('.source-item').forEach(el => el.classList.remove('selected'));
      item.classList.add('selected');

      // Enable start button only if we have a selection area
      startBtn.disabled = !selectionArea;

      if (!selectionArea) {
        showNotification('Click "Position Recording Area" to define the region', 'info');
      }
    }

    function resetSelectAreaButton() {
      const selectAreaBtn = document.getElementById('selectAreaBtn');
      selectAreaBtn.disabled = false;
      selectAreaBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="2" y="2" width="20" height="20" rx="2"/>
          <path d="M7 2v20M17 2v20M2 12h20M2 7h5M2 17h5M17 17h5M17 7h5"/>
        </svg>
        Position Recording Area
      `;
    }

    async function openSelectionWindow() {
      const selectAreaBtn = document.getElementById('selectAreaBtn');
      
      // Prevent multiple clicks
      if (selectAreaBtn.disabled) return;
      
      try {
        // Disable button during selection process
        selectAreaBtn.disabled = true;
        selectAreaBtn.textContent = 'Selecting...';
        
        // Get available displays
        const displays = await window.electronAPI.getDisplays();
        
        if (displays.length === 1) {
          // Only one display, skip modal and open selection directly
          showNotification('Position the recording area...', 'info');
          const selection = await window.electronAPI.openSelectionWindow(displays[0].id, true);
          handleSelectionResult(selection);
        } else {
          // Multiple displays, show modal
          showMonitorModal(displays);
        }
      } catch (error) {
        console.error('Error opening selection window:', error);
        showNotification('Error opening selection window', 'error');
        resetSelectAreaButton();
      }
    }

    function showMonitorModal(displays) {
      const modal = document.getElementById('monitorModal');
      const monitorList = document.getElementById('monitorList');
      
      // Populate monitor list
      monitorList.innerHTML = '';
      displays.forEach((display, index) => {
        const isPrimary = display.bounds.x === 0 && display.bounds.y === 0;
        const item = document.createElement('div');
        item.className = 'monitor-item';
        const scalePercent = Math.round(display.scaleFactor * 100);
        const scaleInfo = display.scaleFactor !== 1 ? ` • ${scalePercent}% scale` : '';
        item.innerHTML = `
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="2" y="3" width="20" height="14" rx="2" />
            <line x1="8" y1="21" x2="16" y2="21" />
            <line x1="12" y1="17" x2="12" y2="21" />
          </svg>
          <div class="monitor-info">
            <div class="monitor-name">Monitor ${index + 1}${isPrimary ? ' (Primary)' : ''}${scaleInfo}</div>
            <div class="monitor-details">${display.bounds.width} × ${display.bounds.height}</div>
          </div>
        `;
        item.addEventListener('click', async () => {
          modal.classList.remove('show');
          showNotification('Position the recording area...', 'info');
          const selection = await window.electronAPI.openSelectionWindow(display.id, true);
          handleSelectionResult(selection);
        });
        monitorList.appendChild(item);
      });
      
      modal.classList.add('show');
    }

    // Handle cancel button in modal
    document.getElementById('cancelMonitorBtn').addEventListener('click', () => {
      document.getElementById('monitorModal').classList.remove('show');
      resetSelectAreaButton();
    });

    function handleSelectionResult(selection) {
      // Always re-enable the button after selection process
      resetSelectAreaButton();
      
      if (selection) {
        selectionArea = selection;

        // Update the preview
        const previewEl = document.getElementById('selectionPreview');
        const scaleInfo = selection.displayScaleFactor !== 1 ? ` (${Math.round(selection.displayScaleFactor * 100)}% scale)` : '';
        previewEl.textContent = `Region: ${selection.width} × ${selection.height}${scaleInfo} at (${selection.x}, ${selection.y})`;
        previewEl.classList.add('has-selection');

        startBtn.disabled = false;
        showNotification(`Selection set: ${selection.width}×${selection.height}`, 'success');
      } else {
        showNotification('Selection cancelled', 'info');
      }
    }

    async function startRecording() {
      if (!selectedSource) {
        showNotification('Select a source first', 'error');
        return;
      }

      // Check if selection mode but no area defined
      if (selectedSource.id === 'selection' && !selectionArea) {
        showNotification('Please draw a selection area first', 'error');
        return;
      }

      try {
        let sourceId = selectedSource.id;

        // For selection recording, we need to get the screen source that contains the selection
        if (selectedSource.id === 'selection') {
          const sources = await window.electronAPI.getSources();
          
          if (sources.length > 0) {
            // Try to find the screen source for the specific display
            let matchingSource = null;
            
            if (selectionArea.displayId) {
              // Try multiple matching strategies
              // 1. Try exact display_id match (as string)
              matchingSource = sources.find(s => s.display_id && String(s.display_id) === String(selectionArea.displayId));
              
              // 2. If no match, try to match by screen index in the name
              if (!matchingSource && sources.length > 1) {
                // Get all displays to find the index
                const displays = await window.electronAPI.getDisplays();
                const displayIndex = displays.findIndex(d => d.id === selectionArea.displayId);
                
                if (displayIndex >= 0 && displayIndex < sources.length) {
                  matchingSource = sources[displayIndex];
                }
              }
              
              // 3. If still no match, try to find by name matching
              if (!matchingSource) {
                // Screen sources typically named "Screen 1", "Screen 2", etc.
                matchingSource = sources.find(s => s.name && s.name.toLowerCase().includes('screen'));
              }
            }
            
            // Fall back to first screen source if no match
            sourceId = matchingSource ? matchingSource.id : sources[0].id;
          } else {
            showNotification('No screen source available', 'error');
            return;
          }
        }

        const screenConstraints = {
          audio: systemAudioCheckbox.checked ? { mandatory: { chromeMediaSource: 'desktop' } } : false,
          video: { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: sourceId } }
        };

        mediaStream = await navigator.mediaDevices.getUserMedia(screenConstraints);

        if (micAudioCheckbox.checked) {
          try {
            const micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            const audioContext = new AudioContext();
            const destination = audioContext.createMediaStreamDestination();

            if (mediaStream.getAudioTracks().length > 0) {
              const screenAudioSource = audioContext.createMediaStreamSource(new MediaStream(mediaStream.getAudioTracks()));
              screenAudioSource.connect(destination);
            }

            const micSource = audioContext.createMediaStreamSource(micStream);
            micSource.connect(destination);

            const videoTrack = mediaStream.getVideoTracks()[0];
            const mixedAudioTrack = destination.stream.getAudioTracks()[0];
            mediaStream = new MediaStream([videoTrack, mixedAudioTrack]);
          } catch (micError) {
            console.warn('Could not access microphone:', micError);
          }
        }

        // For selection recording, we need to crop the video using canvas
        if (selectedSource.id === 'selection' && selectionArea) {
          const videoTrack = mediaStream.getVideoTracks()[0];
          const settings = videoTrack.getSettings();

          // Create a video element to capture the stream
          const videoEl = document.createElement('video');
          videoEl.srcObject = new MediaStream([videoTrack]);
          videoEl.muted = true;
          
          // Wait for video to be ready
          await new Promise((resolve) => {
            videoEl.onloadedmetadata = () => resolve();
          });
          
          await videoEl.play();

          // Get display information for proper scaling
          const displayScaleFactor = selectionArea.displayScaleFactor || 1;
          const displayBounds = selectionArea.displayBounds;
          
          // Canvas dimensions should match the logical pixels from selection
          const canvas = document.createElement('canvas');
          canvas.width = selectionArea.width;
          canvas.height = selectionArea.height;
          const ctx = canvas.getContext('2d', { 
            alpha: false,
            desynchronized: true 
          });
          
          // Set canvas rendering quality
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';

          // IMPORTANT: Use the actual video element dimensions, not settings
          // The settings can report a different resolution than what's actually rendered
          const actualVideoWidth = videoEl.videoWidth;
          const actualVideoHeight = videoEl.videoHeight;

          // The video capture resolution vs display logical resolution
          const displayLogicalWidth = displayBounds.width;
          const displayLogicalHeight = displayBounds.height;
          
          // Calculate scale using actual video dimensions
          const actualScale = actualVideoWidth / displayLogicalWidth;
          
          // Selection coordinates relative to display origin (in logical pixels)
          const relativeX = selectionArea.x - displayBounds.x;
          const relativeY = selectionArea.y - displayBounds.y;
          
          // Convert to video pixels using the actual scale
          const cropX = relativeX * actualScale;
          const cropY = relativeY * actualScale;
          const cropWidth = selectionArea.width * actualScale;
          const cropHeight = selectionArea.height * actualScale;

          // Draw cropped region to canvas at 30fps
          const drawFrame = () => {
            if (!isRecording && !isPaused) return;
            try {
              ctx.drawImage(
                videoEl,
                cropX,
                cropY,
                cropWidth,
                cropHeight,
                0,
                0,
                selectionArea.width,
                selectionArea.height
              );
            } catch (err) {
              console.error('Error drawing frame:', err);
            }
            if (isRecording || isPaused) {
              requestAnimationFrame(drawFrame);
            }
          };

          // Start drawing
          isRecording = true; // Set early so drawFrame loop works
          drawFrame();

          // Get canvas stream
          const canvasStream = canvas.captureStream(30);

          // Add audio track if exists
          const audioTracks = mediaStream.getAudioTracks();
          if (audioTracks.length > 0) {
            canvasStream.addTrack(audioTracks[0]);
          }

          // Use the cropped stream for recording
          mediaStream = canvasStream;

          // Store video element for cleanup
          mediaStream._videoEl = videoEl;
          mediaStream._originalVideoTrack = videoTrack;
        }

        preview.srcObject = mediaStream;
        previewOverlay.classList.add('hidden');

        const options = { mimeType: 'video/webm; codecs=vp9' };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'video/webm; codecs=vp8';
        }
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'video/webm';
        }

        mediaRecorder = new MediaRecorder(mediaStream, options);
        recordedChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) recordedChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          const selectedFormat = outputFormatSelect.value;
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const buffer = await blob.arrayBuffer();

          // Show converting notification for non-webm formats
          if (selectedFormat !== 'webm') {
            showNotification('Converting to ' + selectedFormat.toUpperCase() + '...', 'info');
          }

          const result = await window.electronAPI.saveVideo(buffer, selectedFormat);
          if (result.success) showNotification('Recording saved as ' + selectedFormat.toUpperCase(), 'success');
          else if (!result.canceled) showNotification(result.error || 'Error saving', 'error');
        };

        mediaRecorder.start(1000);
        isRecording = true;
        isPaused = false;
        timerInterval = setInterval(updateTimer, 1000);

        updateStatus('Recording');
        startBtn.style.display = 'none';
        pauseBtn.disabled = false;
        stopBtn.disabled = false;
        resetBtn.disabled = true;
      } catch (error) {
        console.error('Error starting recording:', error);
        showNotification('Error: ' + error.message, 'error');
      }
    }

    function togglePause() {
      if (!mediaRecorder) return;

      if (isPaused) {
        mediaRecorder.resume();
        timerInterval = setInterval(updateTimer, 1000);
        isPaused = false;
        pauseBtn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="currentColor">
            <rect x="6" y="4" width="4" height="16"/>
            <rect x="14" y="4" width="4" height="16"/>
          </svg>
          Pause
        `;
        updateStatus('Recording');
      } else {
        mediaRecorder.pause();
        clearInterval(timerInterval);
        isPaused = true;
        pauseBtn.innerHTML = `
          <svg viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5,3 19,12 5,21"/>
          </svg>
          Resume
        `;
        updateStatus('Paused');
      }
    }

    function stopRecording() {
      if (!mediaRecorder) return;

      mediaRecorder.stop();

      // Clean up video element if used for selection recording
      if (mediaStream._videoEl) {
        mediaStream._videoEl.pause();
        mediaStream._videoEl.srcObject = null;
      }
      if (mediaStream._originalVideoTrack) {
        mediaStream._originalVideoTrack.stop();
      }

      if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
      clearInterval(timerInterval);

      isRecording = false;
      isPaused = false;

      updateStatus('Stopped');
      startBtn.style.display = 'flex';
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      stopBtn.disabled = true;
      resetBtn.disabled = false;
      pauseBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="currentColor">
          <rect x="6" y="4" width="4" height="16"/>
          <rect x="14" y="4" width="4" height="16"/>
        </svg>
        Pause
      `;
      preview.srcObject = null;
      previewOverlay.classList.remove('hidden');
    }

    function resetRecorder() {
      elapsedSeconds = 0;
      timerDisplay.textContent = '00:00:00';
      recordedChunks = [];
      selectedSource = null;
      selectionArea = null;

      document.querySelectorAll('.source-item').forEach(el => el.classList.remove('selected'));

      // Clear selection preview
      const previewEl = document.getElementById('selectionPreview');
      if (previewEl) {
        previewEl.textContent = '';
        previewEl.classList.remove('has-selection');
      }

      updateStatus('Ready');
      startBtn.disabled = true;
      resetBtn.disabled = true;

      loadSources();
      showNotification('Reset complete', 'success');
    }

    startBtn.addEventListener('click', startRecording);
    pauseBtn.addEventListener('click', togglePause);
    stopBtn.addEventListener('click', stopRecording);
    resetBtn.addEventListener('click', resetRecorder);

    // Window control handlers
    document.getElementById('minimizeBtn').addEventListener('click', () => {
      window.electronAPI.minimizeWindow();
    });
    document.getElementById('maximizeBtn').addEventListener('click', () => {
      window.electronAPI.maximizeWindow();
    });
    document.getElementById('closeBtn').addEventListener('click', () => {
      window.electronAPI.closeWindow();
    });

    // GitHub link handler
    document.getElementById('githubLink').addEventListener('click', (e) => {
      e.preventDefault();
      if (window.electronAPI && window.electronAPI.openExternal) {
        window.electronAPI.openExternal('https://github.com/belinda-hagen/ScreenRecorder');
      } else {
        window.open('https://github.com/belinda-hagen/ScreenRecorder', '_blank');
      }
    });

    loadSources();
    checkFfmpeg();
  </script>
</body>

</html>
